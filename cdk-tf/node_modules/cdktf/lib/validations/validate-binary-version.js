"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateBinaryVersion = void 0;
const child_process_1 = require("child_process");
const semver = require("semver");
/**
 * A validation that can be applied to a construct that will error if the
 * construct is being used in an environment with a version of a binary lower than the specified version.
 */
class ValidateBinaryVersion {
    constructor(binary, versionConstraint, versionCommand, hint) {
        this.binary = binary;
        this.versionConstraint = versionConstraint;
        this.versionCommand = versionCommand;
        this.hint = hint;
    }
    validate() {
        try {
            const versionOfCommand = child_process_1.execSync(this.versionCommand, {
                stdio: "pipe",
            }).toString();
            const semverRegex = /\d+\.\d+\.\d+/;
            const version = versionOfCommand.match(semverRegex);
            if (!version) {
                return [
                    `Could not determine version of ${this.binary} (running ${this.versionCommand})`,
                ];
            }
            if (!semver.satisfies(version[0], this.versionConstraint)) {
                return [
                    `${this.binary} version ${version[0]} is lower than the required version ${this.versionConstraint} for this construct. ${this.hint || ""}`,
                ];
            }
            return [];
        }
        catch (e) {
            return [
                `Could not determine version of ${this.binary}, ${this.versionCommand} failed: ${e}`,
            ];
        }
    }
}
exports.ValidateBinaryVersion = ValidateBinaryVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtYmluYXJ5LXZlcnNpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ2YWxpZGF0ZS1iaW5hcnktdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxpREFBeUM7QUFDekMsaUNBQWlDO0FBRWpDOzs7R0FHRztBQUNILE1BQWEscUJBQXFCO0lBQ2hDLFlBQ1ksTUFBYyxFQUNkLGlCQUF5QixFQUN6QixjQUFzQixFQUN0QixJQUFhO1FBSGIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBUTtRQUN6QixtQkFBYyxHQUFkLGNBQWMsQ0FBUTtRQUN0QixTQUFJLEdBQUosSUFBSSxDQUFTO0lBQ3RCLENBQUM7SUFFRyxRQUFRO1FBQ2IsSUFBSTtZQUNGLE1BQU0sZ0JBQWdCLEdBQUcsd0JBQVEsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUNyRCxLQUFLLEVBQUUsTUFBTTthQUNkLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUVkLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQztZQUNwQyxNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDWixPQUFPO29CQUNMLGtDQUFrQyxJQUFJLENBQUMsTUFBTSxhQUFhLElBQUksQ0FBQyxjQUFjLEdBQUc7aUJBQ2pGLENBQUM7YUFDSDtZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRTtnQkFDekQsT0FBTztvQkFDTCxHQUFHLElBQUksQ0FBQyxNQUFNLFlBQ1osT0FBTyxDQUFDLENBQUMsQ0FDWCx1Q0FDRSxJQUFJLENBQUMsaUJBQ1Asd0JBQXdCLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxFQUFFO2lCQUMxQyxDQUFDO2FBQ0g7WUFDRCxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPO2dCQUNMLGtDQUFrQyxJQUFJLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxjQUFjLFlBQVksQ0FBQyxFQUFFO2FBQ3JGLENBQUM7U0FDSDtJQUNILENBQUM7Q0FDRjtBQXRDRCxzREFzQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHsgSVZhbGlkYXRpb24gfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gXCJzZW12ZXJcIjtcblxuLyoqXG4gKiBBIHZhbGlkYXRpb24gdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIGNvbnN0cnVjdCB0aGF0IHdpbGwgZXJyb3IgaWYgdGhlXG4gKiBjb25zdHJ1Y3QgaXMgYmVpbmcgdXNlZCBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgdmVyc2lvbiBvZiBhIGJpbmFyeSBsb3dlciB0aGFuIHRoZSBzcGVjaWZpZWQgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRlQmluYXJ5VmVyc2lvbiBpbXBsZW1lbnRzIElWYWxpZGF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGJpbmFyeTogc3RyaW5nLFxuICAgIHByb3RlY3RlZCB2ZXJzaW9uQ29uc3RyYWludDogc3RyaW5nLFxuICAgIHByb3RlY3RlZCB2ZXJzaW9uQ29tbWFuZDogc3RyaW5nLFxuICAgIHByb3RlY3RlZCBoaW50Pzogc3RyaW5nXG4gICkge31cblxuICBwdWJsaWMgdmFsaWRhdGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZlcnNpb25PZkNvbW1hbmQgPSBleGVjU3luYyh0aGlzLnZlcnNpb25Db21tYW5kLCB7XG4gICAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIH0pLnRvU3RyaW5nKCk7XG5cbiAgICAgIGNvbnN0IHNlbXZlclJlZ2V4ID0gL1xcZCtcXC5cXGQrXFwuXFxkKy87XG4gICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbk9mQ29tbWFuZC5tYXRjaChzZW12ZXJSZWdleCk7XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB2ZXJzaW9uIG9mICR7dGhpcy5iaW5hcnl9IChydW5uaW5nICR7dGhpcy52ZXJzaW9uQ29tbWFuZH0pYCxcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25bMF0sIHRoaXMudmVyc2lvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgYCR7dGhpcy5iaW5hcnl9IHZlcnNpb24gJHtcbiAgICAgICAgICAgIHZlcnNpb25bMF1cbiAgICAgICAgICB9IGlzIGxvd2VyIHRoYW4gdGhlIHJlcXVpcmVkIHZlcnNpb24gJHtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbkNvbnN0cmFpbnRcbiAgICAgICAgICB9IGZvciB0aGlzIGNvbnN0cnVjdC4gJHt0aGlzLmhpbnQgfHwgXCJcIn1gLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIHZlcnNpb24gb2YgJHt0aGlzLmJpbmFyeX0sICR7dGhpcy52ZXJzaW9uQ29tbWFuZH0gZmFpbGVkOiAke2V9YCxcbiAgICAgIF07XG4gICAgfVxuICB9XG59XG4iXX0=