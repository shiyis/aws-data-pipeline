"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformDynamicExpression = void 0;
const _1 = require(".");
const tokens_1 = require("./tokens");
const stack_trace_1 = require("./tokens/private/stack-trace");
const DYNAMIC_EXPRESSION_SYMBOL = Symbol.for("cdktf/TerraformDynamicBlock");
/**
 * A TerraformDynamicExpression is returned by TerraformIterator.dynamic
 * and can be passed to list attributes of e.g. TerraformResources
 * As it resolves to a for expression, it can be used directly on attributes of
 * a list(object) type (or similar) and in Terraform functions that take a list.
 * When used in attributes that are of a block type which need to be modeled as
 * a dynamic block, the listMapper for that attribute will change this to a
 * TerraformDynamicBlock, which in turn will be properly handled by the
 * processDynamicAttributes() utility function.
 */
class TerraformDynamicExpression {
    constructor(args) {
        Object.defineProperty(this, DYNAMIC_EXPRESSION_SYMBOL, { value: true });
        this.creationStack = stack_trace_1.captureStackTrace();
        this.iterator = args.iterator;
        this.content = args.content;
    }
    /**
     * resolves this as a Terraform for expression.
     * This allows using iterator.dynamic() on attributes that are not blocks but
     * lists of objects (which is not visible to the user when working with provider
     * mappings as it is abstracted away)
     */
    resolve() {
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                // resolve nested Lazy values (within this.content) for a for expression
                context.iteratorContext = "FOR_EXPRESSION";
                // returns [ for key, value in forEachExpr : content ]
                // context.resolve is required for the iteratorContext to be correctly passed
                // to Lazy values within this.content
                return context.resolve(_1.forExpression(this.iterator._getForEachExpression(), this.content));
            },
        });
    }
    toString() {
        return tokens_1.Token.asString(this);
    }
    /**
     * Turn this Dynamic Expression into JSON
     *
     * Called automatically when JSON.stringify() is called on this.
     */
    toJSON() {
        return "<unresolved-terraform-dynamic-expression>";
    }
    static isTerraformDynamicExpression(x) {
        return (x !== null && typeof x === "object" && DYNAMIC_EXPRESSION_SYMBOL in x);
    }
}
exports.TerraformDynamicExpression = TerraformDynamicExpression;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLWR5bmFtaWMtZXhwcmVzc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlcnJhZm9ybS1keW5hbWljLWV4cHJlc3Npb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBR0Esd0JBQWtDO0FBQ2xDLHFDQUFvRDtBQUNwRCw4REFBaUU7QUFFakUsTUFBTSx5QkFBeUIsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFFNUU7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSwwQkFBMEI7SUFLckMsWUFBWSxJQUdYO1FBQ0MsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsYUFBYSxHQUFHLCtCQUFpQixFQUFFLENBQUM7UUFDekMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzlCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxPQUFPO1FBQ1osT0FBTyxhQUFJLENBQUMsUUFBUSxDQUFDO1lBQ25CLE9BQU8sRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUNuQix3RUFBd0U7Z0JBQ3hFLE9BQU8sQ0FBQyxlQUFlLEdBQUcsZ0JBQWdCLENBQUM7Z0JBQzNDLHNEQUFzRDtnQkFDdEQsNkVBQTZFO2dCQUM3RSxxQ0FBcUM7Z0JBQ3JDLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FDcEIsZ0JBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUNuRSxDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxjQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTTtRQUNKLE9BQU8sMkNBQTJDLENBQUM7SUFDckQsQ0FBQztJQUVNLE1BQU0sQ0FBQyw0QkFBNEIsQ0FDeEMsQ0FBTTtRQUVOLE9BQU8sQ0FDTCxDQUFDLEtBQUssSUFBSSxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSSx5QkFBeUIsSUFBSSxDQUFDLENBQ3RFLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUF4REQsZ0VBd0RDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB7IElUZXJyYWZvcm1JdGVyYXRvciB9IGZyb20gXCIuL3RlcnJhZm9ybS1pdGVyYXRvclwiO1xuaW1wb3J0IHsgZm9yRXhwcmVzc2lvbiB9IGZyb20gXCIuXCI7XG5pbXBvcnQgeyBJUmVzb2x2YWJsZSwgTGF6eSwgVG9rZW4gfSBmcm9tIFwiLi90b2tlbnNcIjtcbmltcG9ydCB7IGNhcHR1cmVTdGFja1RyYWNlIH0gZnJvbSBcIi4vdG9rZW5zL3ByaXZhdGUvc3RhY2stdHJhY2VcIjtcblxuY29uc3QgRFlOQU1JQ19FWFBSRVNTSU9OX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJjZGt0Zi9UZXJyYWZvcm1EeW5hbWljQmxvY2tcIik7XG5cbi8qKlxuICogQSBUZXJyYWZvcm1EeW5hbWljRXhwcmVzc2lvbiBpcyByZXR1cm5lZCBieSBUZXJyYWZvcm1JdGVyYXRvci5keW5hbWljXG4gKiBhbmQgY2FuIGJlIHBhc3NlZCB0byBsaXN0IGF0dHJpYnV0ZXMgb2YgZS5nLiBUZXJyYWZvcm1SZXNvdXJjZXNcbiAqIEFzIGl0IHJlc29sdmVzIHRvIGEgZm9yIGV4cHJlc3Npb24sIGl0IGNhbiBiZSB1c2VkIGRpcmVjdGx5IG9uIGF0dHJpYnV0ZXMgb2ZcbiAqIGEgbGlzdChvYmplY3QpIHR5cGUgKG9yIHNpbWlsYXIpIGFuZCBpbiBUZXJyYWZvcm0gZnVuY3Rpb25zIHRoYXQgdGFrZSBhIGxpc3QuXG4gKiBXaGVuIHVzZWQgaW4gYXR0cmlidXRlcyB0aGF0IGFyZSBvZiBhIGJsb2NrIHR5cGUgd2hpY2ggbmVlZCB0byBiZSBtb2RlbGVkIGFzXG4gKiBhIGR5bmFtaWMgYmxvY2ssIHRoZSBsaXN0TWFwcGVyIGZvciB0aGF0IGF0dHJpYnV0ZSB3aWxsIGNoYW5nZSB0aGlzIHRvIGFcbiAqIFRlcnJhZm9ybUR5bmFtaWNCbG9jaywgd2hpY2ggaW4gdHVybiB3aWxsIGJlIHByb3Blcmx5IGhhbmRsZWQgYnkgdGhlXG4gKiBwcm9jZXNzRHluYW1pY0F0dHJpYnV0ZXMoKSB1dGlsaXR5IGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVGVycmFmb3JtRHluYW1pY0V4cHJlc3Npb24gaW1wbGVtZW50cyBJUmVzb2x2YWJsZSB7XG4gIHB1YmxpYyByZWFkb25seSBjcmVhdGlvblN0YWNrOiBzdHJpbmdbXTtcbiAgcHVibGljIHJlYWRvbmx5IGl0ZXJhdG9yOiBJVGVycmFmb3JtSXRlcmF0b3I7XG4gIHB1YmxpYyByZWFkb25seSBjb250ZW50OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHtcbiAgICBpdGVyYXRvcjogSVRlcnJhZm9ybUl0ZXJhdG9yO1xuICAgIGNvbnRlbnQ6IHsgW2tleTogc3RyaW5nXTogYW55IH07XG4gIH0pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgRFlOQU1JQ19FWFBSRVNTSU9OX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLmNyZWF0aW9uU3RhY2sgPSBjYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuaXRlcmF0b3IgPSBhcmdzLml0ZXJhdG9yO1xuICAgIHRoaXMuY29udGVudCA9IGFyZ3MuY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXNvbHZlcyB0aGlzIGFzIGEgVGVycmFmb3JtIGZvciBleHByZXNzaW9uLlxuICAgKiBUaGlzIGFsbG93cyB1c2luZyBpdGVyYXRvci5keW5hbWljKCkgb24gYXR0cmlidXRlcyB0aGF0IGFyZSBub3QgYmxvY2tzIGJ1dFxuICAgKiBsaXN0cyBvZiBvYmplY3RzICh3aGljaCBpcyBub3QgdmlzaWJsZSB0byB0aGUgdXNlciB3aGVuIHdvcmtpbmcgd2l0aCBwcm92aWRlclxuICAgKiBtYXBwaW5ncyBhcyBpdCBpcyBhYnN0cmFjdGVkIGF3YXkpXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZSgpOiBhbnkge1xuICAgIHJldHVybiBMYXp5LmFueVZhbHVlKHtcbiAgICAgIHByb2R1Y2U6IChjb250ZXh0KSA9PiB7XG4gICAgICAgIC8vIHJlc29sdmUgbmVzdGVkIExhenkgdmFsdWVzICh3aXRoaW4gdGhpcy5jb250ZW50KSBmb3IgYSBmb3IgZXhwcmVzc2lvblxuICAgICAgICBjb250ZXh0Lml0ZXJhdG9yQ29udGV4dCA9IFwiRk9SX0VYUFJFU1NJT05cIjtcbiAgICAgICAgLy8gcmV0dXJucyBbIGZvciBrZXksIHZhbHVlIGluIGZvckVhY2hFeHByIDogY29udGVudCBdXG4gICAgICAgIC8vIGNvbnRleHQucmVzb2x2ZSBpcyByZXF1aXJlZCBmb3IgdGhlIGl0ZXJhdG9yQ29udGV4dCB0byBiZSBjb3JyZWN0bHkgcGFzc2VkXG4gICAgICAgIC8vIHRvIExhenkgdmFsdWVzIHdpdGhpbiB0aGlzLmNvbnRlbnRcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzb2x2ZShcbiAgICAgICAgICBmb3JFeHByZXNzaW9uKHRoaXMuaXRlcmF0b3IuX2dldEZvckVhY2hFeHByZXNzaW9uKCksIHRoaXMuY29udGVudClcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBUb2tlbi5hc1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIHRoaXMgRHluYW1pYyBFeHByZXNzaW9uIGludG8gSlNPTlxuICAgKlxuICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIEpTT04uc3RyaW5naWZ5KCkgaXMgY2FsbGVkIG9uIHRoaXMuXG4gICAqL1xuICB0b0pTT04oKTogYW55IHtcbiAgICByZXR1cm4gXCI8dW5yZXNvbHZlZC10ZXJyYWZvcm0tZHluYW1pYy1leHByZXNzaW9uPlwiO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpc1RlcnJhZm9ybUR5bmFtaWNFeHByZXNzaW9uKFxuICAgIHg6IGFueVxuICApOiB4IGlzIFRlcnJhZm9ybUR5bmFtaWNFeHByZXNzaW9uIHtcbiAgICByZXR1cm4gKFxuICAgICAgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBEWU5BTUlDX0VYUFJFU1NJT05fU1lNQk9MIGluIHhcbiAgICApO1xuICB9XG59XG4iXX0=