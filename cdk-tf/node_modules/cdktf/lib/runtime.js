"use strict";
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------
// PROPERTY MAPPERS
//
// These are used while converting generated classes/property bags to Terraform JSON objects
//
// We use identity mappers for the primitive types. These don't do anything but are there to make the code
// generation work out nicely (so the code generator doesn't need to emit different code for primitive
Object.defineProperty(exports, "__esModule", { value: true });
exports.isComplexElement = exports.canInspect = exports.hashMapper = exports.listMapper = exports.numberToTerraform = exports.anyToTerraform = exports.booleanToTerraform = exports.stringToTerraform = void 0;
const encoding_1 = require("./tokens/private/encoding");
Object.defineProperty(exports, "isComplexElement", { enumerable: true, get: function () { return encoding_1.isComplexElement; } });
const tokens_1 = require("./tokens");
const terraform_dynamic_block_1 = require("./terraform-dynamic-block");
const terraform_dynamic_expression_1 = require("./terraform-dynamic-expression");
// eslint-disable-next-line jsdoc/require-jsdoc
function identity(x) {
    return x;
}
exports.stringToTerraform = identity;
exports.booleanToTerraform = identity;
exports.anyToTerraform = identity;
exports.numberToTerraform = identity;
/**
 * @param isBlockType blocks and lists of objects need to be handled different in Terraform
 *                    but are represented exactly the same in generated bindings
 *                    currently this is used to resolve TerraformDynamicBlocks if not within
 *                    a block type (will be resolved to a for expression for those instead of
 *                    a dynamic block)
 */
function listMapper(elementMapper, isBlockType) {
    return (x) => {
        if (!canInspect(x)) {
            return x;
        }
        // replace dynamic expressions for block types so they can be detected and replaced properly by processDynamicAttributes()
        // which also relocates them to dynamic.attributeName (something we can't do when resolving a value, put it somewhere else)
        // if isBlockType is false, the TerraformDynamicExpression that is present will be resolved (it implements IResolvable) to a
        // for expression directly (which can be used e.g. within Terraform functions or for attributes that are not of a block type)
        if (terraform_dynamic_expression_1.TerraformDynamicExpression.isTerraformDynamicExpression(x) &&
            isBlockType) {
            return terraform_dynamic_block_1.TerraformDynamicBlock.fromDynamicExpression(x);
        }
        if (!Array.isArray(x)) {
            return x;
        }
        return x.map(elementMapper);
    };
}
exports.listMapper = listMapper;
// eslint-disable-next-line jsdoc/require-jsdoc
function hashMapper(elementMapper) {
    return (x) => {
        if (!canInspect(x)) {
            return x;
        }
        // Check if it's a token object
        if (encoding_1.containsComplexElement(x)) {
            return x;
        }
        if (tokens_1.Tokenization.isResolvable(x)) {
            return x;
        }
        // We can't treat strings as hashes (likely a token or a misconfiguration)
        if (typeof x === "string") {
            return x;
        }
        if (encoding_1.containsMapToken(x)) {
            return x;
        }
        const ret = {};
        Object.keys(x).forEach((key) => {
            ret[key] = elementMapper(x[key]);
        });
        return ret;
    };
}
exports.hashMapper = hashMapper;
/**
 * Return whether this object can be validated at all
 *
 * True unless it's undefined
 */
function canInspect(x) {
    // Note: using weak equality on purpose, we also want to catch undefined
    return x != null;
}
exports.canInspect = canInspect;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJ1bnRpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMseUVBQXlFO0FBQ3pFLG1CQUFtQjtBQUNuQixFQUFFO0FBQ0YsNEZBQTRGO0FBQzVGLEVBQUU7QUFDRiwwR0FBMEc7QUFDMUcsc0dBQXNHOzs7QUFFdEcsd0RBSW1DO0FBaUcxQixpR0FuR1AsMkJBQWdCLE9BbUdPO0FBaEd6QixxQ0FBd0M7QUFDeEMsdUVBQWtFO0FBQ2xFLGlGQUE0RTtBQUs1RSwrQ0FBK0M7QUFDL0MsU0FBUyxRQUFRLENBQUMsQ0FBTTtJQUN0QixPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFWSxRQUFBLGlCQUFpQixHQUFXLFFBQVEsQ0FBQztBQUNyQyxRQUFBLGtCQUFrQixHQUFXLFFBQVEsQ0FBQztBQUN0QyxRQUFBLGNBQWMsR0FBVyxRQUFRLENBQUM7QUFDbEMsUUFBQSxpQkFBaUIsR0FBVyxRQUFRLENBQUM7QUFFbEQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsVUFBVSxDQUN4QixhQUFxQixFQUNyQixXQUFxQjtJQUVyQixPQUFPLENBQUMsQ0FBTSxFQUFFLEVBQUU7UUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNsQixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsMEhBQTBIO1FBQzFILDJIQUEySDtRQUMzSCw0SEFBNEg7UUFDNUgsNkhBQTZIO1FBQzdILElBQ0UseURBQTBCLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxDQUFDO1lBQzFELFdBQVcsRUFDWDtZQUNBLE9BQU8sK0NBQXFCLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkQ7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNyQixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzlCLENBQUMsQ0FBQztBQUNKLENBQUM7QUExQkQsZ0NBMEJDO0FBRUQsK0NBQStDO0FBQy9DLFNBQWdCLFVBQVUsQ0FBQyxhQUFxQjtJQUM5QyxPQUFPLENBQUMsQ0FBTSxFQUFFLEVBQUU7UUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNsQixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsK0JBQStCO1FBQy9CLElBQUksaUNBQXNCLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUVELElBQUkscUJBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDaEMsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUVELDBFQUEwRTtRQUMxRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUN6QixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsSUFBSSwyQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN2QixPQUFPLENBQUMsQ0FBQztTQUNWO1FBRUQsTUFBTSxHQUFHLEdBQVEsRUFBRSxDQUFDO1FBRXBCLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDN0IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQWhDRCxnQ0FnQ0M7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLENBQU07SUFDL0Isd0VBQXdFO0lBQ3hFLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQztBQUNuQixDQUFDO0FBSEQsZ0NBR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUFJPUEVSVFkgTUFQUEVSU1xuLy9cbi8vIFRoZXNlIGFyZSB1c2VkIHdoaWxlIGNvbnZlcnRpbmcgZ2VuZXJhdGVkIGNsYXNzZXMvcHJvcGVydHkgYmFncyB0byBUZXJyYWZvcm0gSlNPTiBvYmplY3RzXG4vL1xuLy8gV2UgdXNlIGlkZW50aXR5IG1hcHBlcnMgZm9yIHRoZSBwcmltaXRpdmUgdHlwZXMuIFRoZXNlIGRvbid0IGRvIGFueXRoaW5nIGJ1dCBhcmUgdGhlcmUgdG8gbWFrZSB0aGUgY29kZVxuLy8gZ2VuZXJhdGlvbiB3b3JrIG91dCBuaWNlbHkgKHNvIHRoZSBjb2RlIGdlbmVyYXRvciBkb2Vzbid0IG5lZWQgdG8gZW1pdCBkaWZmZXJlbnQgY29kZSBmb3IgcHJpbWl0aXZlXG5cbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29tcGxleEVsZW1lbnQsXG4gIGlzQ29tcGxleEVsZW1lbnQsXG4gIGNvbnRhaW5zTWFwVG9rZW4sXG59IGZyb20gXCIuL3Rva2Vucy9wcml2YXRlL2VuY29kaW5nXCI7XG5pbXBvcnQgeyBUb2tlbml6YXRpb24gfSBmcm9tIFwiLi90b2tlbnNcIjtcbmltcG9ydCB7IFRlcnJhZm9ybUR5bmFtaWNCbG9jayB9IGZyb20gXCIuL3RlcnJhZm9ybS1keW5hbWljLWJsb2NrXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1EeW5hbWljRXhwcmVzc2lvbiB9IGZyb20gXCIuL3RlcnJhZm9ybS1keW5hbWljLWV4cHJlc3Npb25cIjtcblxuLy8gdnMuIGNvbXBsZXggdHlwZXMpLlxuZXhwb3J0IHR5cGUgTWFwcGVyID0gKHg6IGFueSkgPT4gYW55O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZnVuY3Rpb24gaWRlbnRpdHkoeDogYW55KSB7XG4gIHJldHVybiB4O1xufVxuXG5leHBvcnQgY29uc3Qgc3RyaW5nVG9UZXJyYWZvcm06IE1hcHBlciA9IGlkZW50aXR5O1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5Ub1RlcnJhZm9ybTogTWFwcGVyID0gaWRlbnRpdHk7XG5leHBvcnQgY29uc3QgYW55VG9UZXJyYWZvcm06IE1hcHBlciA9IGlkZW50aXR5O1xuZXhwb3J0IGNvbnN0IG51bWJlclRvVGVycmFmb3JtOiBNYXBwZXIgPSBpZGVudGl0eTtcblxuLyoqXG4gKiBAcGFyYW0gaXNCbG9ja1R5cGUgYmxvY2tzIGFuZCBsaXN0cyBvZiBvYmplY3RzIG5lZWQgdG8gYmUgaGFuZGxlZCBkaWZmZXJlbnQgaW4gVGVycmFmb3JtXG4gKiAgICAgICAgICAgICAgICAgICAgYnV0IGFyZSByZXByZXNlbnRlZCBleGFjdGx5IHRoZSBzYW1lIGluIGdlbmVyYXRlZCBiaW5kaW5nc1xuICogICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseSB0aGlzIGlzIHVzZWQgdG8gcmVzb2x2ZSBUZXJyYWZvcm1EeW5hbWljQmxvY2tzIGlmIG5vdCB3aXRoaW5cbiAqICAgICAgICAgICAgICAgICAgICBhIGJsb2NrIHR5cGUgKHdpbGwgYmUgcmVzb2x2ZWQgdG8gYSBmb3IgZXhwcmVzc2lvbiBmb3IgdGhvc2UgaW5zdGVhZCBvZlxuICogICAgICAgICAgICAgICAgICAgIGEgZHluYW1pYyBibG9jaylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNYXBwZXIoXG4gIGVsZW1lbnRNYXBwZXI6IE1hcHBlcixcbiAgaXNCbG9ja1R5cGU/OiBib29sZWFuXG4pOiBNYXBwZXIge1xuICByZXR1cm4gKHg6IGFueSkgPT4ge1xuICAgIGlmICghY2FuSW5zcGVjdCh4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBkeW5hbWljIGV4cHJlc3Npb25zIGZvciBibG9jayB0eXBlcyBzbyB0aGV5IGNhbiBiZSBkZXRlY3RlZCBhbmQgcmVwbGFjZWQgcHJvcGVybHkgYnkgcHJvY2Vzc0R5bmFtaWNBdHRyaWJ1dGVzKClcbiAgICAvLyB3aGljaCBhbHNvIHJlbG9jYXRlcyB0aGVtIHRvIGR5bmFtaWMuYXR0cmlidXRlTmFtZSAoc29tZXRoaW5nIHdlIGNhbid0IGRvIHdoZW4gcmVzb2x2aW5nIGEgdmFsdWUsIHB1dCBpdCBzb21ld2hlcmUgZWxzZSlcbiAgICAvLyBpZiBpc0Jsb2NrVHlwZSBpcyBmYWxzZSwgdGhlIFRlcnJhZm9ybUR5bmFtaWNFeHByZXNzaW9uIHRoYXQgaXMgcHJlc2VudCB3aWxsIGJlIHJlc29sdmVkIChpdCBpbXBsZW1lbnRzIElSZXNvbHZhYmxlKSB0byBhXG4gICAgLy8gZm9yIGV4cHJlc3Npb24gZGlyZWN0bHkgKHdoaWNoIGNhbiBiZSB1c2VkIGUuZy4gd2l0aGluIFRlcnJhZm9ybSBmdW5jdGlvbnMgb3IgZm9yIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbm90IG9mIGEgYmxvY2sgdHlwZSlcbiAgICBpZiAoXG4gICAgICBUZXJyYWZvcm1EeW5hbWljRXhwcmVzc2lvbi5pc1RlcnJhZm9ybUR5bmFtaWNFeHByZXNzaW9uKHgpICYmXG4gICAgICBpc0Jsb2NrVHlwZVxuICAgICkge1xuICAgICAgcmV0dXJuIFRlcnJhZm9ybUR5bmFtaWNCbG9jay5mcm9tRHluYW1pY0V4cHJlc3Npb24oeCk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICByZXR1cm4geC5tYXAoZWxlbWVudE1hcHBlcik7XG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gaGFzaE1hcHBlcihlbGVtZW50TWFwcGVyOiBNYXBwZXIpOiBNYXBwZXIge1xuICByZXR1cm4gKHg6IGFueSkgPT4ge1xuICAgIGlmICghY2FuSW5zcGVjdCh4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIHRva2VuIG9iamVjdFxuICAgIGlmIChjb250YWluc0NvbXBsZXhFbGVtZW50KHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBpZiAoVG9rZW5pemF0aW9uLmlzUmVzb2x2YWJsZSh4KSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgdHJlYXQgc3RyaW5ncyBhcyBoYXNoZXMgKGxpa2VseSBhIHRva2VuIG9yIGEgbWlzY29uZmlndXJhdGlvbilcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGlmIChjb250YWluc01hcFRva2VuKHgpKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBjb25zdCByZXQ6IGFueSA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoeCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICByZXRba2V5XSA9IGVsZW1lbnRNYXBwZXIoeFtrZXldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhpcyBvYmplY3QgY2FuIGJlIHZhbGlkYXRlZCBhdCBhbGxcbiAqXG4gKiBUcnVlIHVubGVzcyBpdCdzIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuSW5zcGVjdCh4OiBhbnkpIHtcbiAgLy8gTm90ZTogdXNpbmcgd2VhayBlcXVhbGl0eSBvbiBwdXJwb3NlLCB3ZSBhbHNvIHdhbnQgdG8gY2F0Y2ggdW5kZWZpbmVkXG4gIHJldHVybiB4ICE9IG51bGw7XG59XG5leHBvcnQgeyBpc0NvbXBsZXhFbGVtZW50IH07XG4iXX0=